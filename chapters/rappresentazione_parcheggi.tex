\chapter{Rappresentazione dei parcheggi sulla mappa}

Tutti i procedimenti descritti in precedenza, come la raccolta dei dati, le
operazioni che vengono effettuate su di essi, la predizione del tipo di 
parcheggio, ecc. portano al risultato di ottenere una serie di istanze
di parcheggio, all'interno del database, che possiedono varie informazioni.
Ogni parcheggio, tra le altre cose, può essere fornito di:
\begin{itemize}
    \item \textbf{coordinate finali}, che indicano il punto geografico dove l'auto ha 
    parcheggiato, sono sempre presenti (a volte potrebbero essere invalide)
    \item \textbf{tipo di parcheggio selezionato dall'utente}, presente per i parcheggi
    per cui è stata selezionata manualmente una etichietta di classificazione.
    \item \textbf{tipo di parcheggio predetto dal modello ML}, presente per i parcheggi
    per cui è stata effettuata la predizione con il modello (a meno di eccezioni, dovrebbe
    essere sempre presente)
    \item \textbf{valore di heading finale}, presente per i parcheggi
    per cui è stata effettuata la predizione con il modello (a meno di eccezioni, dovrebbe
    essere sempre presente)
\end{itemize}
Queste informazioni possono essere utilizzate per fornire dei benefici all'utente.
Di fatto, tutto il lavoro che porta a questo punto ha come scopo finale lo 
sfruttamento delle informazioni acquisite per arricchire l'esperienza 
dell'utente in qualche modo.\\
In particolare, l'obiettivo principale era l'ottenimento del tipo di parcheggio, ma 
attraverso l'intero procedimento è stato possibile ottenere anche il valore della 
bussola senza dover fare sforzi aggiuntivi.\\
I due utilizzi principali di queste informazioni che per il momento vengono fatti sono
mostrare visivamente sulla mappa i tipi di parcheggio, alle rispettive coordinate, e
migliorare l'algoritmo di creazione dei match tra utenti che lasciano un parcheggio e 
quelli che ne cercano uno.\\
Mostrare i parcheggi sulla mappa offre all'utente la possibilità di poter trovare 
facilmente delle zone di posteggio in un'area a proprio piacimento. Integrare
nelle figure dei parcheggi anche altri dettagli, come il tipo di parcheggio o 
l'orientamento, può ulteriormente facilitare l'esperienza dell'utente, ad esempio
facendogli capire in anticipo com è fatto il parcheggio che sta cercando.
Ad ogni modo, la rappresentazione grafica che è stata implementata all'interno
dell'app GeneroCity si tratta di una versione non definitiva, quindi poco affinata e poco
testata sull' utente finale. Dato che l'app non è ancora stata rilasciata, questa 
rappresentazione è utilizzata principalmente per lo sviluppo ed è destinata a subire
grandi miglioramenti dal punto di vista grafico e dell'interfaccia. Nonostante ciò,
la logica che la gestisce e il proprio ciclo di vita, che viene giostrato dagli eventi
dell'interfaccia utente, sono sufficentemente maturi e pronti ad un potenziale rilascio.\\
Invece, per quanto riguarda l'algoritmo di matching, esso viene utilizzato per 
rendere possibile uno scambio di parcheggio tra un utente che sta lasciando lo 
stesso e un altro che ne sta cercando uno. Essendo a conoscenza dei tipi dei 
parcheggi, al momento della ricerca di un parcheggio disponibile, da parte di un
utente che possa prendere il posto lasciato, si potranno preferire i posti in cui
è più probabile che l'auto di colui che cerca entri e scartare quelli in cui invece
probabilmente l'auto non entrerà a causa delle dimensioni.\\
Tuttavia, in sviluppi futuri, queste informazioni potranno essere sfruttate anche in
altri ambiti, o semplicemente per migliorare in altri modi i servizi già esistenti.


\section{Recupero dei parcheggi nella zona visualizzata} 

Mostrare una rappresentazione grafica dei parcheggi all'utente richiede, come prima cosa,
l'ottenimento delle informazioni necessarie su di essi. Per ogni \emph{Car} presente nel 
sistema, vengono salvati nel database tutti i parcheggi effettuati, costituiti dalle 
informazioni descritte in precedenza, ed altre, tra cui il timestamp del caricamento.\\
Occorre quindi un metodo per scaricare le informazioni riguardanti i parcheggi che 
devono essere rappresentati sulla mappa. In particolare, quando l'utente osserva una
specifica porzione della mappa, ha bisogno di vedere tutti i parcheggi che si trovano 
in quella determinata zona e nessun altro. Questo ha permesso una progettazione che 
minimizzasse la quantità di richieste inviate all'API backend e allo stesso tempo 
mostrasse visivamente tutti i parcheggi in maniera fluida e senza provocare
interruzioni all'esperienza utente. Chiaramente, l'area inquadrata nella mappa 
cambia molto frequentemente e a seconda di come l'utente interagisce con essa. 
Quindi, l'algoritmo di recupero dei parcheggi deve tenere conto anche di questo fatto
ed impedire che vengano invocate un numero eccessivo di chiamate verso il server.\\
Dunque, è stato necessario introdurre una nuova funzione fornita dall'API del backend
di GeneroCity, che permettesse di scaricare le istanze dei parcheggi in maniera
intelligente. Successivamente, è stato progettato un algoritmo che potesse sfruttare
al meglio la nuova funzione introdotta e quindi scaricare le informazioni sui parcheggi,
tenendo conto di tutti i vincoli presenti e le necessità dell'utente finale.

\subsection{Chiamata API per la richiesta dei parcheggi in un'area}

In GeneroCity iOS sono state utilizzate le mappe di Apple, che vengono distribuite
attraverso la libreria \emph{MapKit}. La classe responsabile della rappresentazione
grafica di una mappa è \emph{MKMapView}. Quest'ultima possiede un attributo \textbf{region}
che corrisponde all'informazione sull'area mostrata sullo schermo nell'istante corrente.
Infatti, quando l'area visibile sul display cambia (ad esempio in seguito ad uno swipe
dell'utente), anche la \textbf{region} viene aggiornata. Questo oggetto è formato dalle
coordinate del centro dell'area interessata e da due valori che rappresentano lo 
scostamento di longitudine e quello di latitudine. Gli scostamenti indicano rispettivamente gli
angoli, espressi in gradi, tra la longitudine minore e quella maggiore e la latitudine 
minore e quella maggiore visibili attualmente sullo schermo. In questo modo, si è a conoscenza della porzione esatta di mappa visibile dall'utente
in ogni istante.\\
Si può utilizzare questa informazione per ottenere le istanze dei parcheggi che si trovano 
nel database e che sono stati registrati all'interno dell'area richiesta.
Dati i parametri \textbf{lat} (latitudine del centro dell'area), \textbf{lon} 
(longitudine del centro dell'area), \textbf{deltaLat} (scostamento di latitudine), 
\textbf{deltaLon} (scostamento di longitudine), l'interrogazione
al database consiste semplicemente nella selezione dei parcheggi \textbf{p}, relativi
a qualsiasi auto, tali che:
\begin{center}
    $ \textbf{lat} - \textbf{deltaLat} \le \textbf{p.latitude} \le \textbf{lat} + \textbf{deltaLat}$\\
    e\\
    $ \textbf{lon} - \textbf{deltaLon} \le \textbf{p.longitude} \le \textbf{lon} + \textbf{deltaLon}$
\end{center}
Questa interrogazione è stata inserita all'interno di una nuova chiamata API, di tipo "GET".
Questa chiamata è stata definita "Get area park list", in quanto restituisce la lista di 
parcheggi presenti all'interno dell'area indicata.\\
I parametri accettati dalla chiamata sono tutti e soli quelli appena definiti,
tutti di tipo float. Inoltre, tutti i parametri sono obbligatori, in quanto 
sono tutti essenziali per il corretto calcolo del risultato.\\
La risposta fornita da questa chiamata consiste in una lista di oggetti in formato JSON, 
contenenti le informazioni dei singoli parcheggi trovati. Ogni oggetto di un parcheggio
contiene: le coordinate, il timestamp, le etichette del tipo di parcheggio (sia quella 
selezionata dall'utente che quella predetta dal modello classificatore), l'heading, ecc.
Qualora nel database alcuni di questi campi non fossero obbligatori, i rispettivi valori 
restituiti potrebbero essere nulli.\\
All'interno del modulo API dell'app Generocity iOS è stata quindi aggiunta una una funzione
di interfaccia, in grado di effettuare una chiamata alla funzionalità backend appena descritta.
% TODO: maybe add a picture of the architecture for the call (frontend > backend > DB -<)
Tra i vari parametri della funzione è presente una callback, che viene eseguita nel momento in cui
viene ricevuta la risposta dal server. Questa callback contiene un oggetto JSON, che è esattamente
la lista delle istanze dei parcheggi trovati. In questo modo, è possibile ottenere la lista desiderata in maniera asincrona, direttamente con una chiamata a funzione. 

\subsection{Scheduling delle richieste}

Come è stato anticipato, i parcheggi che devono essere mostrati sulla mappa devono essere 
scaricati con un criterio che tenga conto di diversi vincoli. Al centro di tutto vi è
l'esperienza dell'utente. Infatti, si è cercato di progettare un algoritmo di recupero dei 
parcheggi che permettesse di mostrare immediatamente, o comunque con poco ritardo, le 
istanze sulla mappa. Inoltre, si è tentato di far mantenere questa proprietà anche in seguito
ad un potenziale cambiamento della regione di mappa visibile sullo schermo, causato da uno
swipe dell'utente stesso, o da qualsiasi evento all'interno dell'app. Questo può essere
classificato come un requisito funzionale. Di contro, possono essere individuati diversi
requisiti non funzionali che pongono dei vincoli e delle limitazioni che devono essere 
rispettati per garantire la fattibilità di questa funzionalità:
\begin{itemize}
    \item \textbf{richiesta della sola area visibile}: al crescere del numero di parcheggi 
    salvati nel database, aumenta la densità dei parcheggi in una data zona e quindi 
    aumenta il numero di potenziali istanze da scaricare. Al fine di contenere le 
    dimensioni del payload delle risposte ricevute dal server, conviene ridurre il più
    possibile la grandezza della zona richiesta, idealmente soltanto l'area circostante
    la \textbf{region} attualmente visibile. Questo meccanismo non sarà comunque 
    sufficiente per quando il numero dei parcheggi presenti nel database diverrà
    molto grande. Con sviluppi futuri dell'app si potrà risolvere il problema, ad 
    esempio richiedendo solo i parcheggi registrati in un certo intervallo di tempo,
    oppure ponendo un limite alla lunghezza della lista in risposta.
    \item \textbf{intervallo di tempo tra due richieste all'API}: la regione della mappa
    visualizzata sullo schermo può cambiare molte volte e molto rapidamente. Questo fatto
    potrebbe creare problemi se implicasse un invio non controllato di richieste. Infatti,
    dato che l'evento di cambiamento della \textbf{region} della mappa viene lanciato per 
    ogni piccola variazione, l'effettuare una nuova richiesta ogni volta potrebbe 
    generare decine di chiamate al secondo. Questa cosa sarebbe chiaramente inutile e 
    deleteria, perché il server verrebbe inondato di richieste che oltretutto 
    richiederebbero una lista quasi uguale di parcheggi. Anche nel lato client questo 
    sarebbe dannoso, dovendo gestire un traffico troppo elevato di richieste e risposte
    HTTP. Viene naturale pensare quindi che sia necessario un limite sul numero di 
    richieste effettuabili in un certo intervallo di tempo.
    \item \textbf{richieste di aree molto grandi}: la mappa offre la possibilità di 
    modificare lo zoom della visuale, così da ingrandire e rimpicciolire l'area 
    visibile sullo schermo. Quando viene applicato uno zoom molto basso e quindi 
    l'area visibile si ingrandisce in maniera considerevole, le zone di posteggio
    diventano troppo piccole e invisibili all'utente. Questo significa che quando
    la \textbf{region} della mappa è molto grande, non ha senso mostrare la 
    rappresentazione dei parcheggi. Inoltre, richiedere la lista dei parcheggi
    registrati in una grande zona porterebbe al problema già discusso di una
    quantità di istanze trovate troppo grande. Questo farebbe sorgere dei 
    problemi relativi anche alla quantità elevata di memoria occupata nel
    sistema operativo per l'applicazione.
    \item \textbf{richieste della stessa area}: quando la \textbf{region} della mappa
    cambia di un piccolo delta, la maggior parte dei parcheggi richiesti sarebbero
    gli stessi che erano stati ottenuti alla richiesta precedente. Quindi, si possono
    evitare richieste duplicate per la stessa zona e occorre un metodo per evitare 
    di inviare richieste inutili.
\end{itemize}
Con lo scopo di soddisfare tutti questi requisiti, è stato progettato un algoritmo di 
scaricamento dei parcheggi che effettua diversi controlli prima di procedere con una 
nuova richiesta. \'E stata così definita una classe \emph{ParkingOverlaysLoader}, 
responsabile dell'esecuzione delle richieste all'API. Un'istanza di questa classe
viene gestita dalla mappa. In particolare, vengono sfruttati degli eventi generati
dalla mappa per chiamare il metodo \emph{load()} di \emph{ParkingOverlaysLoader} e
quindi effettuare una nuova richiesta, se questa viene permessa.\\
Come già annunciato, la mappa genera un evento ogni volta che la \textbf{region} è 
soggetta ad un piccolo cambiamento. Questo evento può essere catturato attraverso
il metodo \emph{mapViewDidChangeVisibleRegion()}, offerto dal delegate della mappa
stessa. In questo modo, si può effettuare una chiamata al metodo \emph{load()} e
lasciar gestire al \emph{ParkingOverlaysLoader} la scelta di compiere o no una
nuova richiesta.\\
Dopo la prima chiamata, che genera sempre una richiesta all'API, entreranno in regime
una serie di condizioni che ogni volta controlleranno se sia il caso di procedere con
una nuova richiesta. Definendo \textbf{MIN\_TIME\_BETWEEN\_QUERIES} come il tempo minimo
che deve passare tra una richiesta e la successiva e \textbf{MAX\_REGION\_DELTA} come 
il massimo scostamento (angolo in gradi) tra i due estremi visibili della mappa per 
cui abbia senso effettuare una richiesta, vengono controllate le seguenti condizioni:
\begin{center}
    $ \textbf{mapView.region.span.latitudeDelta} > \textbf{MAX\_REGION\_DELTA} $
\end{center}

\section{Disegno dei parcheggi sulla mappa} 

% TODO: also add toggle description

\section{Informazione sul tipo di parcheggio} 


\section{Informazione sull'orientamento del parcheggio} Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\section{Approccio community-driven}

% TODO: discuss this 
I parcheggi vengono aggiunti automaticamente quando gli utenti li effettuano. 
Per evitare parcheggi invalidi, si mostrano per bene quando tanti parcheggi sono stati
fatti nello stesso posto, maggiore sicurezza ...
In questo modo l'utente ha l'informazione su dove si trova una zona di posteggio, tutto
attraverso l'automatismo dell'app, non c'è bisogno che esse vengano impostate dagli sviluppatori

\section{Beneficio dell'utente} 

\subsection{Informazione visiva}

\subsection{Disponibilità del parcheggio per auto di una certa dimensione}
% controllare che un auto possa entrare nel parcheggio, controllando il tipo 
% di parcheggio, se esso è parallelo e l'auto che sta arrivando è più lunga
% di quella di colui che se ne va, essa potrebbe non entrare nel parcheggio